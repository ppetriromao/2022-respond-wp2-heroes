---
title: "sr_explore_heroes"
author: "Papoula Petri-Romao"
date: "2022-11-15"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

require(pacman)
p_load(tidyverse,
       psych,
       lme4)

ds <- readRDS("data/heroes_wp2_anonymised.rds")


```

currently "prefer not to issues" are not recoded as -992. therefore we are recoding them here. This should run when the final ipd dataset is corrected. 

```{r basic-recoding}

ds <- ds %>%	        
        
  mutate(sd03 = recode(sd03,"2"= NA_character_),	        
        
         # sd05 = recode(sd05, "6" = NA_character_),	        
        
         # sd06 = recode(sd06, "6" = NA_character_),	        
        
         # tr13 = recode(tr13, "5" = NA_character_),	        
        
         # mp19 = recode(mp19, "4" = NA_character_),	        
        
         mp25b = recode(mp25b, "3" = NA_character_),	# RMT: "2" = "I do not know"        
        
         # ep31 = recode(ep31, "2" = NA_character_),	        
        
         ep32 = recode(ep32,	        
        
                       "2"= NA_character_,	        
        
                       "3"= NA_character_),	        
        
         ep32a = recode(ep32a, "4" = NA_character_),	        
        
         # sp64 = recode(sp64, "2" = NA_character_),	        
        
         # sp65 = recode(sp65, "2" = NA_character_),	        
        
         # sp66 = recode(sp66, "2" = NA_character_),	        
        
         sp66b1 = recode(sp66b1, "6" = NA_character_),	# RMT: Do you actually use these stressors?        
        
         sp66b2 = recode(sp66b2, "6" = NA_character_),	        
        
         sp66b3 = recode(sp66b3, "6" = NA_character_),	        
        
         sp66b4 = recode(sp66b4, "6" = NA_character_),	        
        
         sp66b5 = recode(sp66b5, "6" = NA_character_),	        
        
         sp66b6 = recode(sp66b6, "6" = NA_character_),	        
        
         sp66b7 = recode(sp66b7, "6" = NA_character_),	        
        
        )

```

# separating datset

```{r waves}
# dataset wave 1
ds1 <- ds %>%
  dplyr::filter(wave=="1") %>%
  dplyr::filter(assessment_week !=-993)%>%
  group_by(hashed_id)


## robertos recoding, at this point only wave one FIX for other waves 
ds1 <- 
  ds1 %>% 
  mutate(
   mp25a = fct_recode(mp25a,
                      NULL = "2"),
    mp25b = fct_recode(mp25b,
                       NULL = "2",
                       NULL = "3"),
    mp25d = fct_recode(mp25d,
                       NULL = "4"), # Option 4 added in waves 2 and 3
    ep32 = fct_recode(ep32,
                      NULL = "2",
                      NULL = "3"),
    # mp24 = as.numeric(mp24),
    mp18 = fct_recode(mp18,
                      NULL = "2"),
       mp19 = fct_recode(mp19,
                      NULL = "4")# added by papoula
    )
# dataset of wave two
ds2 <- ds %>%
  dplyr::filter(wave=="2") %>%
  dplyr::filter(assessment_week !=-993)%>%
  group_by(hashed_id)
  
# dataset of wave three
ds3 <- ds %>%
  dplyr::filter(wave=="3") %>%
  dplyr::filter(assessment_week !=-993)%>%
  group_by(hashed_id)

# here I try to create a complete dataset 
dsc <- ds %>%
  dplyr::filter(hashed_id %in% ds1$hashed_id &
                hashed_id %in% ds2$hashed_id &
                hashed_id %in% ds3$hashed_id)%>%
  group_by(hashed_id)


ds %>%
  filter(wave == "1") %>% 
  select(assessment_week) %>%
  table()
  
```

# replace NAs

```{r function,include=FALSE}


ds <- ds %>% mutate(across(where(is.factor), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_))) %>% 
  mutate(across(where(is.numeric), .fns = ~recode(.x, `-993`= NA_real_, `-991`= NA_real_,))) %>% 
  mutate(across(where(is.character) & !hashed_id, .fns = ~recode(.x,  "-991" = NA_character_,"-993" = NA_character_)))

ds1 <- ds1 %>% mutate(across(where(is.factor), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_))) %>% 
  mutate(across(where(is.numeric), .fns = ~recode(.x, `-993`= NA_real_, `-991`= NA_real_,))) %>% 
  mutate(across(where(is.character), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_)))

ds2 <- ds2 %>% mutate(across(where(is.factor), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_))) %>% 
  mutate(across(where(is.numeric), .fns = ~recode(.x, `-993`= NA_real_, `-991`= NA_real_,))) %>% 
  mutate(across(where(is.character), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_)))

ds3 <- ds3 %>% mutate(across(where(is.factor), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_))) %>% 
  mutate(across(where(is.numeric), .fns = ~recode(.x, `-993`= NA_real_, `-991`= NA_real_,))) %>% 
  mutate(across(where(is.character), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_)))

dsc <- dsc %>% mutate(across(where(is.factor), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_))) %>% 
  mutate(across(where(is.numeric), .fns = ~recode(.x, `-993`= NA_real_, `-991`= NA_real_,))) %>% 
  mutate(across(where(is.character), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_)))

```

# Rober's proofs

I will now focus on the first wave and include only the variables I'm interested in

```{r roberds}

df <- ds
df1 <- 
  df %>% 
  filter(wave == 1,
           !is.na(assessment_week)) %>%  # This removes "fake" missing data
  select(hashed_id,
         tr15,
         tr16,
         tr17,
         mp25a,
         mp25b:mp25e,
         ep32,
         mp18,
         mp19,
         mp21,
         mp23,
         mp22,
         mp25,
         mp24,
         starts_with(c("phq", "ad"))) 
```

At this stage, I only recode NAs, so that we can look at the actual distribution of stressors

```{r robermutate}
df1 <- 
  df1 %>% 
  mutate(
   mp25a = fct_recode(mp25a,
                      NULL = "2"),
    mp25b = fct_recode(mp25b,
                       NULL = "2",
                       NULL = "3"),
    mp25d = fct_recode(mp25d,
                       NULL = "4"), # Option 4 added in waves 2 and 3
    ep32 = fct_recode(ep32,
                      NULL = "2",
                      NULL = "3"),
    # mp24 = as.numeric(mp24),
    mp18 = fct_recode(mp18,
                      NULL = "2"),
       mp19 = fct_recode(mp19,
                      NULL = "4")# added by papoula
   )

df1 <- 
  df1 %>% 
  mutate(
    ghq_total = select(., c(ad34:ad45)) %>% rowSums(),
    phq_total = select(., c(phq68:phq76)) %>% rowSums()
  )
```

## Correlation matrix

```{r robercorr}
df1 %>% 
  mutate(
    across(
      where(is.factor),
      as.character
    ),
    across(
      where(is.character),
      as.numeric
    )
  ) %>% 
  select(!c(hashed_id,
            phq68:ad45)
  ) %>% 
  psych::cor.plot(.)
```

Linear models

```{r robertlinear}
# GHQ12

df1 %>% 
  select(!c(hashed_id,
            phq68:ad45)) %>% 
  mutate(
    across(
      c(tr16, tr17, mp25c, mp25d, mp25e, mp21, mp23, mp22),
      as.character
    ),
    across(
      where(is.character),
      as.numeric
    )
  ) %>% 
  map(~ lm(ghq_total ~ .x, df1) %>% summary())

# PHQ-9

df1 %>% 
  select(!c(hashed_id,
            phq68:ad45)) %>% 
  mutate(
    across(
      c(tr16, tr17, mp25c, mp25d, mp25e, mp21, mp23, mp22),
      as.character
    ),
    across(
      where(is.character),
      as.numeric
    )
  ) %>% 
  map(~ lm(ghq_total ~ .x, df1) %>% summary())


```


# Stressors 

TR16: days worked, should more than 5 days be a stressor? *RMT Probably 6-7 days a week should be a stressor: many HCWs did not rest for weeks*.
TR17: hours worked on those days == should that be a stressors *RMT Hard to interpret: 16- or 24-hour shift are common among HCWs in Spain*
MP25c: stigma, if any agreement then stressor *RMT We did a paper on this. Is linked to MH. I would include it*

MP25d: frequency of conflicts, does it make sense to count? *RMT This I don't trust very much. Perhaps MP25e is better (violence due to job)*

EP32a: should we include feeling remorse? is that somehow the stressor severity? *We used just EP32 in a previous work and it did fine. Having to discriminate is usually stressing enough and is often followed by remorse. I am also afraid that there may be much more missing data in the EP32a.*

EP27a-d; double check variable code

psychological support: I suggest two alternatives of recoding. also, I am not sure that we can say that they are stressors. because they could also reduce stress. so maybe we should take them out all together

trust: again, it might be worth looking at them separately, as I am not sure we can say that they are stressors. 

RA56: what are the answer options?


 _FIXED notes 29/11 PPR_

ehc_4: in wave one, everyone should be one, not sure what happened. >> answer options appear to change for MP18aa in wave 2 and 3, please check. 

ehc_5: the answer options for MP25b don't appear to correspond with codebook. more options than 1 and 0

ehc7: double check answer options and recoding PPR

ehc8: something is amiss, as based on raw data we would expect over 500 1s. 

ehc9: answer options in codebook are less than actual answer options >> doublecheck ep32

ec_3: MP18ab>> answer options seem to change in wave 2 and 3 

## explanation of recoding
the recoding of stressors are based on the following variables


*EHC stressors*

    - TR15: Assigned to new team in past 3 months. Expected answer format: 0 1.  Basis for ehc_1
    - TR16: Days worked past week. Expected answer format: free.Basis for ehc_2 & ehc_3. 
    - TR17: Hour worked. Expected answer format: free. Basis for ehc_3. 
    - MP18aa: Working in a COVID unit. Expected answer format: 0 1. Basis for: ehc_4 RMT: NOT IN WAVE 1
    - mp25b: death of a patient. Expected answer format:0 1.  Basis for: ehc_5
    - MP25c: stigma. Expected answer format: Likert 1 2 3 4.  Basis for: ehc_6
    - MP25d: conflict at work. Expected answer format: Likert 0 1 2 3 4 5.Basis for: ehc_7
    - MP25e: Violence at work. Expected answer format: Likert 1 2 3 4. Basis for: ehc_8
    - EP32: Need to prioritise covid patients. Expected answer format: 0 1 2(N/A) Basis for: ehc_9


*EC stressors*

    - MP18: close contact. Expected answer format: 0 1 2.  Basis for: ec_1
    - MP21: worried about getting covid. Expected answer format: Likert 0 1 2 3. Basis for: ec_2
    - MP23: worried about infecting someone.Expected answer format: Likert 0 1 2 3.  Basis for: ec_3
    - MP18ab: infection. Expected answer format: 0 1 2. Basis for ec_4 RMT: NOT IN WAVE 1
    - MP22: days isolation. Expected answer format: free. Basis for: ec_5
    - MP25: death close one. Expected answer format: 0 1.  Basis for: ec_5
    - MP25aa: death at work. Expected answer format: 0 1.  Basis for: ec_6 RMT: NOT IN WAVE 1
    

*To potentially add:*

MP24: loved one had covid

*Considered but discarded*

    - EP27a: received training >> strata
    - SD08: live with child. >> regular life, not necessarily a stressor. 
    - SD09: living with elderly >> not a stressor
    - SD10: living with people with disability >> not a stressor
    - MP25g: trust in government >> too subjective, not a stressor
    - MP25e: trust information >> too subjective, not a stressor
    - MP25f: perceived management by leaders
    - MP25fb: perceived management by colleagues
    - R52a-d etc: different types of support received. >> Receiving support could alleviate a stressor or could mark the presence of stress, but we cannot distinguish that. 
    

```{r stressors, echo=TRUE}

stressors <- read.csv("stressors_heroes.csv")

# entire ds -----------------------------------------------------------------------------------
## healthcare worker specific stressors

ds <- ds %>%
  mutate(
    ehc_1 = case_when(tr15 == 1 ~ 1,
                   tr15 == 0 ~ 0), # Assigned to new team in past 3 months
    ehc_2 = case_when(tr16 >= 6 ~ 1,
                      TRUE ~ 0), # days worked past week
    ehc_3 = case_when(tr16 > 5 & tr17 >= 12~ 1,
                      TRUE ~ 0), #  hours worked on those days
    ehc_4 = case_when(mp18aa == 1~1,
                      mp18aa == 0 ~0), # covid-19 unit RMT: strata?
    ehc_5 = case_when(mp25b == 1 ~1,
                      mp25b == 0 ~ 0), # death of patient
    ehc_6 = case_when(mp25c == 1 ~ 0,
                      mp25c == 2 ~ 0,
                      mp25c == 3 ~ 1,
                      mp25c == 4 ~ 1), # stigma
    ehc_7 = case_when(mp25d == 0 ~ 0, # RMT: this is Likert 0 to 3 so I assume this line is not needed
                      mp25d == 1 ~ 1,
                      mp25d == 2 ~ 2,
                      mp25d == 3 ~ 2), # conflicts at work RMT: strata?
    ehc_8 = case_when(mp25e == 1 ~ 0,
                      mp25e == 2 ~ 0,
                      mp25e == 3 ~ 1,
                      mp25e == 4 ~ 1), # violence due to health worker
    ehc_9 = ep32) # need to prioritise patients


## covid stressors
ds <- ds %>%
  mutate(
    ec_1 = mp18, # close contact
    ec_2 = case_when(mp21 == 0 ~0,
                     mp21 == 1 ~1,
                     mp21 == 2 ~1,
                     mp21 == 3 ~1), # worried about getting infected
    ec_3 = case_when(mp23 == 0 ~0,
                     mp23 == 1 ~1,
                     mp23 == 2 ~1,
                     mp23 == 3 ~1), # worried about infecting someone
    ec_4 = case_when(mp18ab == 0 ~0,
                     mp18ab == 1 ~1), # infected with COVID
    ec_5 = case_when(mp22 >=1 ~1
                     ), # days in isolation
    ec_6 = mp25, # death duie to covid
    ec_7 = mp25aa # death at work
      )

# ds1 --------------------------------------

## healthcare worker specific stressors

ds1 <- ds1 %>%
  mutate(
    ehc_1 = case_when(tr15 == 1 ~ 1,
                   tr15 == 0 ~ 0), # Assigned to new team in past 3 months
    ehc_2 = case_when(tr16 >= 6 ~ 1,
                      TRUE ~ 0), # days worked past week
    ehc_3 = case_when((tr16 > 5 & tr17 >= 12)~ 1,
                      TRUE ~ 0), #  hours worked on those days
    ehc_5 = case_when(mp25b == 1 ~1,
                      mp25b == 0 ~ 0), # death of patient
    ehc_6 = case_when(mp25c == 1 ~ 0,
                      mp25c == 2 ~ 0,
                      mp25c == 3 ~ 1,
                      mp25c == 4 ~ 1), # stigma
    ehc_7 = case_when(mp25d == 0 ~ 0, # RMT: this is Likert 0 to 3 so I assume this line is not needed
                      mp25d == 1 ~ 1,
                      mp25d == 2 ~ 2,
                      mp25d == 3 ~ 2), # conflicts at work RMT: strata?
    ehc_8 = case_when(mp25e == 1 ~ 0,
                      mp25e == 2 ~ 0,
                      mp25e == 3 ~ 1,
                      mp25e == 4 ~ 1), # violence due to health worker
    ehc_9 = ep32,
    ehc_10 = case_when(mp19 == 3~ 0,
                       mp19 == 2~ 1,
                       mp19 == 1~ 1,
                       mp19 == 0~ 1,)) # need to prioritise patients


## covid stressors
ds1 <- ds1 %>%
  mutate(
    ec_1 = mp18, # close contact
    ec_2 = case_when(mp21 == 0 ~0,
                     mp21 == 1 ~1,
                     mp21 == 2 ~1,
                     mp21 == 3 ~1), # worried about getting infected
    ec_3 = case_when(mp23 == 0 ~0,
                     mp23 == 1 ~1,
                     mp23 == 2 ~1,
                     mp23 == 3 ~1), # worried about infecting someone
    ec_5 = case_when(mp22 >=1 ~1
                     ), # days in isolation
    ec_6 = mp25, # death duie to covid
    ec_8 = mp25a,
    ec_9 = mp24
      )
```


# decriptives

RMT general comment:
Since we are not sure about anything,
I suggest we focus on the first wave only.
That includes these descriptive tables
(Alternatively, I would show these values stratified by wave)

```{r describe}

# some summaries

e_items <- grep("ehc_|e_rel|et_|eg_|ec_", names(ds), value = TRUE)
e_raw <- c("mp18", "mp21", "mp23", "mp18ab","mp22", "mp25", "mp25aa", "tr15", "tr16", "mp18aa", "mp25b", "mp25c", "mp25d", "mp25e", "ep32")


ehc <- grep("ehc_", names(ds), value = TRUE)

ec <- grep("ec_", names(ds), value = TRUE)

e_rel <- grep("e_rel", names(ds), value = TRUE)
et <- grep("et_", names(ds), value = TRUE)
eg <- grep("eg_", names(ds), value = TRUE)


knitr::kable(psych::describe(ds[e_items]))
knitr::kable(psych::describe(ds[e_raw]))

## hours worked what would be consider impossible values
which(ds[e_raw] > 99, arr.ind = TRUE) 
ds[2025,"tr16"]  <- NA_real_ # impossible value 7777
# ds[2111,"tr16"]  <- NA_real_ # 211 hours worked

## days in isolation, what are impossible values?
which(ds[e_raw] > 50, arr.ind = TRUE)

ggplot2::ggplot(data=ds,aes(x = factor(wave), 
                                y = psych::scoreItems(e_items, ds[e_items])$scores
                                )
                            ) + 
 geom_violin(position=position_dodge(1), 
             trim = FALSE
             ) +
  geom_boxplot(width = 0.05,
  position = position_dodge(0.9) 
  # color = "black"
  )+
  geom_smooth(method = "lm", se=TRUE
              ) +
  ggtitle("Healhtcare worker stressors", subtitle = "")+
  xlab("Timepoints")+
  ylab("E") # RMT: this plot makes sense: more stressors during the first wave (right?)



```



## descriptives by wave 1 only 

```{r deswave1}
# wave 1 --------------------------------------

e_items <- grep("ehc_|e_rel|et_|eg_|ec_", names(ds1), value = TRUE)
e_raw <- c("mp18", "mp21", "mp23","mp22", "mp24", "mp25","mp25a", "mp19", "tr15", "tr16", "mp25b", "mp25c", "mp25d", "mp25e", "ep32")


ehc <- grep("ehc_", names(ds1), value = TRUE)

ec <- grep("ec_", names(ds1), value = TRUE)

e_rel <- grep("e_rel", names(ds1), value = TRUE)
et <- grep("et_", names(ds1), value = TRUE)
eg <- grep("eg_", names(ds1), value = TRUE)

knitr::kable(psych::describe(ds1[e_items]))
knitr::kable(psych::describe(ds1[e_raw]))


## ehc
ds1[c(e_items, "hashed_id")] %>%
  gather("Type", "Value",-hashed_id) %>%
  ggplot(aes(x=as.factor(Value)))+
  geom_bar(position="dodge")+
  facet_wrap(~Type,scales = "free_x") +
  ggtitle("Count of hc stressors", subtitle = "")+
  xlab("Answer")+
  ylab("Count") 

## ehc
ds1[c(e_items, "hashed_id")] %>%
  gather("Type", "Value",-hashed_id) %>%
  table()

## raw
ds1[c(e_raw, "hashed_id")] %>%
  gather("Type", "Value",-hashed_id) %>%
  ggplot(aes(x=as.factor(Value)))+
  geom_bar(position="dodge")+
  facet_wrap(~Type,scales = "free_x") +
  ggtitle("Count of RAW hc stressors", subtitle = "")+
  xlab("Answer")+
  ylab("Count") 


## ec
ds1[c(ec, "hashed_id")] %>%
  gather("Type", "Value",-hashed_id) %>%
  ggplot(aes(x=as.factor(Value)))+
  geom_bar(position="dodge")+
  facet_wrap(~Type,scales = "free_x") +
  ggtitle("Count of covid stressors", subtitle = "")+
  xlab("Answer")+
  ylab("Count") 



```

# Roberto will fix this!

```{r robfreq}

ds1 %>% 
  select(c("mp18", "mp21", "mp23", "mp18ab","mp22", "mp25", "mp25aa", 
           "tr15", "tr16", "mp18aa", "mp25b", "mp25c", "mp25d", "mp25e", "ep32")) %>% 
  select(-hashed_id) %>% 
  map(., ~ prop.table(table(.)))

ds1 %>% 
  select(
    starts_with(c("ehc", "ec"))
  ) %>% 
    select(-hashed_id) %>% 
  map(., ~ prop.table(table(.)))

```


# wave 1

We calculate SR scores based on mental health exposure. 
In the Dynacore studies we base this of GHQ. As we want to know mental health problems and not necessarily symptoms.
However, in RESPOND WP4 we use PHQ & GAd7 as the basis of the SR score, as the sample is highly distressed. This results in a good SR measure. 
Therefore we here compare an SR score based on GHQ and one on PHQ. 

*the results indicate that more investment should be put in the definition of stressors, as there is virtually no different pattern with phq*

Questions:

    - should we impute data in ghq/phq
    - should we impute data in E scores

```{r wave-1}

ds1$ehc <-psych::scoreItems(ehc, ds1[ehc], totals = TRUE)$scores
ds1$ec <-psych::scoreItems(ec, ds1[ec], totals = TRUE)$scores
ds1$E <-psych::scoreItems(c(ehc, ec), ds1[c(ehc, ec)], totals = TRUE)$scores
ds1$ehc_raw <-psych::scoreItems(e_raw, ds1[e_raw])$scores



ghq <- grep("^ad", names(ds1), value = TRUE)
psych::scoreItems(ghq,items=ds1[ghq], impute = "median", totals = TRUE)
ds1$ghq <-psych::scoreItems(ghq,items=ds1[ghq], impute = "median", totals = TRUE)$scores

phq <- grep("^phq..$", names(ds1), value = TRUE)
psych::scoreItems(phq,items=ds1[phq], impute = "median", totals = TRUE)
ds1$phq <-psych::scoreItems(phq,items=ds1[phq], impute = "median", totals = TRUE)$scores



psych::pairs.panels(ds1[c("ehc", "ec", "E", "ehc_raw", "ghq", "phq" )], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             main = "all wave 1"
             )


ds1m <- ds1 %>% 
  filter(nuts_id == "ES300") 



psych::pairs.panels(ds1m[c("ehc", "ec", "E", "ehc_raw", "ghq", "phq" )], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             main = "madrid wave 1"
             )

ds1top <- ds1 %>%                                     
  arrange(desc(ehc)) %>%  
  ungroup()%>%
  slice_max(ehc, prop = .66)


psych::pairs.panels(ds1top[c("ehc", "ec", "E", "ehc_raw", "ghq", "phq" )], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             main = "wave 1 top"
             )

```
## sr scores, ghq, pqhq
Unfortunately, the SR score and GHQ are basically the same. 



```{r sr_score_plot1}

# GHQ SR score
## random slopes and intercepts

EP      <- lm(scale(ghq) ~ poly(scale(E),1,raw = TRUE),data=ds1)  
EP_poly <- lm(scale(ghq) ~ poly(scale(E),2,raw = TRUE),data=ds1)  


### compare model fits
anova(EP,EP_poly,test="Chisq")


### plot differ EP lines

plot <- ggplot(ds1, aes(x = scale(E), y = scale(ghq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(method = "lm") +
  ggtitle("Linear EP line GHQ")

plot <- ggplot(ds1, aes(x = scale(E), y = scale(ghq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
    ggtitle("quadratic E-P line GHQ")


## calc linear SR score
intercept = summary(EP)$coefficients[1]
E_slope = summary(EP)$coefficients[2]

### predicted E wwould be predE = slope*actualE + intercept
### calculate predicted E based on this formula
ds1$P_pred = (intercept + scale(ds1$E)*E_slope)

ds1$SR_ghq= scale(scale(ds1$ghq) - ds1$P_pred)
ds1$RES_ghq = -(ds1$SR_ghq)


## poly SR score
intercept_poly = summary(EP_poly)$coefficients[1]
E_slope_poly = summary(EP_poly)$coefficients[2]
E_slope2_poly = summary(EP_poly)$coefficients[3]

### predicted E wwould be predE = slope*actualE + intercept
## #calculate predicted E based on this formula

ds1$P_pred_poly = (intercept_poly + scale(ds1$E)*E_slope_poly + (scale(ds1$E)^2)*E_slope2_poly)


ds1$SR_poly_ghq = scale(scale(ds1$ghq) -ds1$P_pred_poly)
ds1$RES_poly_ghq <- -(ds1$SR_poly_ghq)

# phq SR score
## random slopes and intercepts

EP      <- lm(scale(phq) ~ poly(scale(E),1,raw = TRUE),data=ds1)  
EP_poly <- lm(scale(phq) ~ poly(scale(E),2,raw = TRUE),data=ds1)  


### compare model fits
anova(EP,EP_poly,test="Chisq")


### plot differ EP lines

plot <- ggplot(ds1, aes(x = scale(E), y = scale(phq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(method = "lm") +
  ggtitle("Linear EP line phq")

plot <- ggplot(ds1, aes(x = scale(E), y = scale(phq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
    ggtitle("quadratic E-P line phq")


## calc linear SR score
intercept = summary(EP)$coefficients[1]
E_slope = summary(EP)$coefficients[2]

### predicted E wwould be predE = slope*actualE + intercept
### calculate predicted E based on this formula
ds1$P_pred = (intercept + scale(ds1$E)*E_slope)

ds1$SR_phq= scale(scale(ds1$phq) - ds1$P_pred)
ds1$RES_phq = -(ds1$SR_phq)


## poly SR score
intercept_poly = summary(EP_poly)$coefficients[1]
E_slope_poly = summary(EP_poly)$coefficients[2]
E_slope2_poly = summary(EP_poly)$coefficients[3]

### predicted E wwould be predE = slope*actualE + intercept
## #calculate predicted E based on this formula

ds1$P_pred_poly = (intercept_poly + scale(ds1$E)*E_slope_poly + (scale(ds1$E)^2)*E_slope2_poly)


ds1$SR_poly_phq = scale(scale(ds1$phq) -ds1$P_pred_poly)
ds1$RES_poly_phq <- -(ds1$SR_poly_phq)


# correlations 
psych::pairs.panels(ds1[c("RES_phq", "RES_poly_phq","RES_ghq", "RES_poly_ghq", "ghq", "phq")], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             main = "over all timepoints"
             )

```

## wave 1 madrid

### sr scores, ghq, pqhq
Unfortunately, the SR score and GHQ are basically the same. 



```{r sr_score_plotmadrid}

# GHQ SR score
## random slopes and intercepts

EP      <- lm(scale(ghq) ~ poly(scale(E),1,raw = TRUE),data=ds1m)  
EP_poly <- lm(scale(ghq) ~ poly(scale(E),2,raw = TRUE),data=ds1m)  


### compare model fits
anova(EP,EP_poly,test="Chisq")


### plot differ EP lines

plot <- ggplot(ds1m, aes(x = scale(E), y = scale(ghq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(method = "lm") +
  ggtitle("Linear EP line GHQ")

plot <- ggplot(ds1m, aes(x = scale(E), y = scale(ghq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
    ggtitle("quadratic E-P line GHQ")


## calc linear SR score
intercept = summary(EP)$coefficients[1]
E_slope = summary(EP)$coefficients[2]

### predicted E wwould be predE = slope*actualE + intercept
### calculate predicted E based on this formula
ds1m$P_pred = (intercept + scale(ds1m$E)*E_slope)

ds1m$SR_ghq= scale(scale(ds1m$ghq) - ds1m$P_pred)
ds1m$RES_ghq = -(ds1m$SR_ghq)


## poly SR score
intercept_poly = summary(EP_poly)$coefficients[1]
E_slope_poly = summary(EP_poly)$coefficients[2]
E_slope2_poly = summary(EP_poly)$coefficients[3]

### predicted E wwould be predE = slope*actualE + intercept
## #calculate predicted E based on this formula

ds1m$P_pred_poly = (intercept_poly + scale(ds1m$E)*E_slope_poly + (scale(ds1m$E)^2)*E_slope2_poly)


ds1m$SR_poly_ghq = scale(scale(ds1m$ghq) -ds1m$P_pred_poly)
ds1m$RES_poly_ghq <- -(ds1m$SR_poly_ghq)

# phq SR score
## random slopes and intercepts

EP      <- lm(scale(phq) ~ poly(scale(E),1,raw = TRUE),data=ds1m)  
EP_poly <- lm(scale(phq) ~ poly(scale(E),2,raw = TRUE),data=ds1m)  


### compare model fits
anova(EP,EP_poly,test="Chisq")


### plot differ EP lines

plot <- ggplot(ds1m, aes(x = scale(E), y = scale(phq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(method = "lm") +
  ggtitle("Linear EP line phq")

plot <- ggplot(ds1m, aes(x = scale(E), y = scale(phq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
    ggtitle("quadratic E-P line phq")


## calc linear SR score
intercept = summary(EP)$coefficients[1]
E_slope = summary(EP)$coefficients[2]

### predicted E wwould be predE = slope*actualE + intercept
### calculate predicted E based on this formula
ds1m$P_pred = (intercept + scale(ds1m$E)*E_slope)

ds1m$SR_phq= scale(scale(ds1m$phq) - ds1m$P_pred)
ds1m$RES_phq = -(ds1m$SR_phq)


## poly SR score
intercept_poly = summary(EP_poly)$coefficients[1]
E_slope_poly = summary(EP_poly)$coefficients[2]
E_slope2_poly = summary(EP_poly)$coefficients[3]

### predicted E wwould be predE = slope*actualE + intercept
## #calculate predicted E based on this formula

ds1m$P_pred_poly = (intercept_poly + scale(ds1m$E)*E_slope_poly + (scale(ds1m$E)^2)*E_slope2_poly)


ds1m$SR_poly_phq = scale(scale(ds1m$phq) -ds1m$P_pred_poly)
ds1m$RES_poly_phq <- -(ds1m$SR_poly_phq)


# correlations 
psych::pairs.panels(ds1m[c("RES_phq", "RES_poly_phq","RES_ghq", "RES_poly_ghq", "ghq", "phq")], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             main = "over all timepoints"
             )

```

## wave 1 top 66%

### sr scores, ghq, pqhq
Unfortunately, the SR score and GHQ are basically the same. 



```{r sr_score_plottop}

# GHQ SR score
## random slopes and intercepts

EP      <- lm(scale(ghq) ~ poly(scale(E),1,raw = TRUE),data=ds1top)  
EP_poly <- lm(scale(ghq) ~ poly(scale(E),2,raw = TRUE),data=ds1top)  


### compare model fits
anova(EP,EP_poly,test="Chisq")


### plot differ EP lines

plot <- ggplot(ds1top, aes(x = scale(E), y = scale(ghq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(method = "lm") +
  ggtitle("Linear EP line GHQ")

plot <- ggplot(ds1top, aes(x = scale(E), y = scale(ghq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
    ggtitle("quadratic E-P line GHQ")


## calc linear SR score
intercept = summary(EP)$coefficients[1]
E_slope = summary(EP)$coefficients[2]

### predicted E wwould be predE = slope*actualE + intercept
### calculate predicted E based on this formula
ds1top$P_pred = (intercept + scale(ds1top$E)*E_slope)

ds1top$SR_ghq= scale(scale(ds1top$ghq) - ds1top$P_pred)
ds1top$RES_ghq = -(ds1top$SR_ghq)


## poly SR score
intercept_poly = summary(EP_poly)$coefficients[1]
E_slope_poly = summary(EP_poly)$coefficients[2]
E_slope2_poly = summary(EP_poly)$coefficients[3]

### predicted E wwould be predE = slope*actualE + intercept
## #calculate predicted E based on this formula

ds1top$P_pred_poly = (intercept_poly + scale(ds1top$E)*E_slope_poly + (scale(ds1top$E)^2)*E_slope2_poly)


ds1top$SR_poly_ghq = scale(scale(ds1top$ghq) -ds1top$P_pred_poly)
ds1top$RES_poly_ghq <- -(ds1top$SR_poly_ghq)

# phq SR score
## random slopes and intercepts

EP      <- lm(scale(phq) ~ poly(scale(E),1,raw = TRUE),data=ds1top)  
EP_poly <- lm(scale(phq) ~ poly(scale(E),2,raw = TRUE),data=ds1top)  


### compare model fits
anova(EP,EP_poly,test="Chisq")


### plot differ EP lines

plot <- ggplot(ds1top, aes(x = scale(E), y = scale(phq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(method = "lm") +
  ggtitle("Linear EP line phq")

plot <- ggplot(ds1top, aes(x = scale(E), y = scale(phq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
    ggtitle("quadratic E-P line phq")


## calc linear SR score
intercept = summary(EP)$coefficients[1]
E_slope = summary(EP)$coefficients[2]

### predicted E wwould be predE = slope*actualE + intercept
### calculate predicted E based on this formula
ds1top$P_pred = (intercept + scale(ds1top$E)*E_slope)

ds1top$SR_phq= scale(scale(ds1top$phq) - ds1top$P_pred)
ds1top$RES_phq = -(ds1top$SR_phq)


## poly SR score
intercept_poly = summary(EP_poly)$coefficients[1]
E_slope_poly = summary(EP_poly)$coefficients[2]
E_slope2_poly = summary(EP_poly)$coefficients[3]

### predicted E wwould be predE = slope*actualE + intercept
## #calculate predicted E based on this formula

ds1top$P_pred_poly = (intercept_poly + scale(ds1top$E)*E_slope_poly + (scale(ds1top$E)^2)*E_slope2_poly)


ds1top$SR_poly_phq = scale(scale(ds1top$phq) -ds1top$P_pred_poly)
ds1top$RES_poly_phq <- -(ds1top$SR_poly_phq)


# correlations 
psych::pairs.panels(ds1top[c("RES_phq", "RES_poly_phq","RES_ghq", "RES_poly_ghq", "ghq", "phq")], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             main = "over all timepoints"
             )

```



## sr scores wave 3 ghq, phq, phqads

```{r sr-wave3}

# # GHQ SR score -------------------------------------------------------------
# ## random slopes and intercepts
# 
# EP      <- lm(scale(ghq) ~ poly(scale(E),1,raw = TRUE),data=ds3)  
# EP_poly <- lm(scale(ghq) ~ poly(scale(E),2,raw = TRUE),data=ds3)  
# 
# 
# ### compare model fits
# anova(EP,EP_poly,test="Chisq")
# 
# 
# ### plot differ EP lines
# 
# plot <- ggplot(ds3, aes(x = scale(E), y = scale(ghq))) +
#   geom_point() +
#   labs(x="E", y="P") +
#   geom_smooth(method = "lm") +
#   ggtitle("Linear EP line GHQ")
# 
# plot <- ggplot(ds3, aes(x = scale(E), y = scale(ghq))) +
#   geom_point() +
#   labs(x="E", y="P") +
#   geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
#     ggtitle("quadratic E-P line GHQ")
# 
# 
# ## calc linear SR score
# intercept = summary(EP)$coefficients[1]
# E_slope = summary(EP)$coefficients[2]
# 
# ### predicted E wwould be predE = slope*actualE + intercept
# ### calculate predicted E based on this formula
# ds3$P_pred = (intercept + scale(ds3$E)*E_slope)
# 
# ds3$SR_ghq= scale(scale(ds3$ghq) - ds3$P_pred)
# ds3$RES_ghq = -(ds3$SR_ghq)
# 
# 
# ## poly SR score
# intercept_poly = summary(EP_poly)$coefficients[1]
# E_slope_poly = summary(EP_poly)$coefficients[2]
# E_slope2_poly = summary(EP_poly)$coefficients[3]
# 
# ### predicted E wwould be predE = slope*actualE + intercept
# ## #calculate predicted E based on this formula
# 
# ds3$P_pred_poly = (intercept_poly + scale(ds3$E)*E_slope_poly + (scale(ds3$E)^2)*E_slope2_poly)
# 
# 
# ds3$SR_poly_ghq = scale(scale(ds3$ghq) -ds3$P_pred_poly)
# ds3$RES_poly_ghq <- -(ds3$SR_poly_ghq)
# 
# # phq SR score------------------------------------------------------
# ## random slopes and intercepts
# 
# EP      <- lm(scale(phq) ~ poly(scale(E),1,raw = TRUE),data=ds3)  
# EP_poly <- lm(scale(phq) ~ poly(scale(E),2,raw = TRUE),data=ds3)  
# 
# 
# ### compare model fits
# anova(EP,EP_poly,test="Chisq")
# 
# 
# ### plot differ EP lines
# 
# plot <- ggplot(ds3, aes(x = scale(E), y = scale(phq))) +
#   geom_point() +
#   labs(x="E", y="P") +
#   geom_smooth(method = "lm") +
#   ggtitle("Linear EP line phq")
# 
# plot <- ggplot(ds3, aes(x = scale(E), y = scale(phq))) +
#   geom_point() +
#   labs(x="E", y="P") +
#   geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
#     ggtitle("quadratic E-P line phq")
# 
# 
# ## calc linear SR score
# intercept = summary(EP)$coefficients[1]
# E_slope = summary(EP)$coefficients[2]
# 
# ### predicted E wwould be predE = slope*actualE + intercept
# ### calculate predicted E based on this formula
# ds3$P_pred = (intercept + scale(ds3$E)*E_slope)
# 
# ds3$SR_phq= scale(scale(ds3$phq) - ds3$P_pred)
# ds3$RES_phq = -(ds3$SR_phq)
# 
# 
# ## poly SR score
# intercept_poly = summary(EP_poly)$coefficients[1]
# E_slope_poly = summary(EP_poly)$coefficients[2]
# E_slope2_poly = summary(EP_poly)$coefficients[3]
# 
# ### predicted E wwould be predE = slope*actualE + intercept
# ## #calculate predicted E based on this formula
# 
# ds3$P_pred_poly = (intercept_poly + scale(ds3$E)*E_slope_poly + (scale(ds3$E)^2)*E_slope2_poly)
# 
# 
# ds3$SR_poly_phq = scale(scale(ds3$phq) -ds3$P_pred_poly)
# ds3$RES_poly_phq <- -(ds3$SR_poly_phq)
# 
# # phqads SR score ---------------------------------------------------------
# ## random slopes and intercepts
# 
# EP      <- lm(scale(phqads) ~ poly(scale(E),1,raw = TRUE),data=ds3)  
# EP_poly <- lm(scale(phqads) ~ poly(scale(E),2,raw = TRUE),data=ds3)  
# 
# 
# ### compare model fits
# anova(EP,EP_poly,test="Chisq")
# 
# 
# ### plot differ EP lines
# 
# plot <- ggplot(ds3, aes(x = scale(E), y = scale(phqads))) +
#   geom_point() +
#   labs(x="E", y="P") +
#   geom_smooth(method = "lm") +
#   ggtitle("Linear EP line phqads")
# 
# plot <- ggplot(ds3, aes(x = scale(E), y = scale(phqads))) +
#   geom_point() +
#   labs(x="E", y="P") +
#   geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
#     ggtitle("quadratic E-P line phqads")
# 
# 
# ## calc linear SR score
# intercept = summary(EP)$coefficients[1]
# E_slope = summary(EP)$coefficients[2]
# 
# ### predicted E wwould be predE = slope*actualE + intercept
# ### calculate predicted E based on this formula
# ds3$P_pred = (intercept + scale(ds3$E)*E_slope)
# 
# ds3$SR_phqads= scale(scale(ds3$phqads) - ds3$P_pred)
# ds3$RES_phqads = -(ds3$SR_phqads)
# 
# 
# ## poly SR score
# intercept_poly = summary(EP_poly)$coefficients[1]
# E_slope_poly = summary(EP_poly)$coefficients[2]
# E_slope2_poly = summary(EP_poly)$coefficients[3]
# 
# ### predicted E wwould be predE = slope*actualE + intercept
# ## #calculate predicted E based on this formula
# 
# ds3$P_pred_poly = (intercept_poly + scale(ds3$E)*E_slope_poly + (scale(ds3$E)^2)*E_slope2_poly)
# 
# 
# ds3$SR_poly_phqads = scale(scale(ds3$phqads) -ds3$P_pred_poly)
# ds3$RES_poly_phqads <- -(ds3$SR_poly_phqads)
# 
# 
# # correlations -----------------------------------------------------
# 
# psych::pairs.panels(ds3[c("RES_phqads", "RES_poly_phqads","RES_phq", "RES_poly_phq","RES_ghq", "RES_poly_ghq", "ghq", "phq", "phqads")], 
#              method = "pearson", # correlation method
#              hist.col = "#00AFBB",
#              density = TRUE,  # show density plots
#              ellipses = TRUE, # show correlation ellipses
#              main = "over all timepoints"
#              )

```



# complete dataset N~230

```{r ds-complete}

# dsc$ehc <-rowSums(dsc[ehc], na.rm = TRUE)
# dsc$ec <-rowSums(dsc[ec], na.rm = TRUE)
# dsc$E <-rowSums(dsc[c(ehc, ec)], na.rm = TRUE)
# dsc$ehc_raw <-rowSums(dsc[e_raw], na.rm = FALSE)
# 
# 
# 
# ghq <- grep("^ad", names(dsc), value = TRUE)
# psych::scoreItems(ghq,items=dsc[ghq], impute = "median", totals = TRUE)
# dsc$ghq <-psych::scoreItems(ghq,items=dsc[ghq], impute = "median", totals = TRUE)$scores
# 
# phq <- grep("^phq..$", names(dsc), value = TRUE)
# psych::scoreItems(phq,items=dsc[phq], impute = "median", totals = TRUE)
# dsc$phq <-psych::scoreItems(phq,items=dsc[phq], impute = "median", totals = TRUE)$scores
# 
# 
# 
# psych::pairs.panels(dsc[c("ehc", "ec", "E", "ehc_raw", "ghq", "phq" )], 
#              method = "pearson", # correlation method
#              hist.col = "#00AFBB",
#              density = TRUE,  # show density plots
#              ellipses = TRUE, # show correlation ellipses
#              main = "over all timepoints"
#              )


```

```{r sr-complete}
# 
# # GHQ SR score
# ## random slopes and intercepts
# 
# EP      <- lm(scale(ghq) ~ poly(scale(E),1,raw = TRUE),data=dsc)  
# EP_poly <- lm(scale(ghq) ~ poly(scale(E),2,raw = TRUE),data=dsc)  
# 
# 
# ### compare model fits
# anova(EP,EP_poly,test="Chisq")
# 
# 
# ### plot differ EP lines
# 
# plot <- ggplot(dsc, aes(x = scale(E), y = scale(ghq))) +
#   geom_point() +
#   labs(x="E", y="P") +
#   geom_smooth(method = "lm") +
#   ggtitle("Linear EP line GHQ")
# 
# plot <- ggplot(dsc, aes(x = scale(E), y = scale(ghq))) +
#   geom_point() +
#   labs(x="E", y="P") +
#   geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
#     ggtitle("quadratic E-P line GHQ")
# 
# 
# ## calc linear SR score
# intercept = summary(EP)$coefficients[1]
# E_slope = summary(EP)$coefficients[2]
# 
# ### predicted E wwould be predE = slope*actualE + intercept
# ### calculate predicted E based on this formula
# dsc$P_pred = (intercept + scale(dsc$E)*E_slope)
# 
# dsc$SR_ghq= scale(scale(dsc$ghq) - dsc$P_pred)
# dsc$RES_ghq = -(dsc$SR_ghq)
# 
# 
# ## poly SR score
# intercept_poly = summary(EP_poly)$coefficients[1]
# E_slope_poly = summary(EP_poly)$coefficients[2]
# E_slope2_poly = summary(EP_poly)$coefficients[3]
# 
# ### predicted E wwould be predE = slope*actualE + intercept
# ## #calculate predicted E based on this formula
# 
# dsc$P_pred_poly = (intercept_poly + scale(dsc$E)*E_slope_poly + (scale(dsc$E)^2)*E_slope2_poly)
# 
# 
# dsc$SR_poly_ghq = scale(scale(dsc$ghq) -dsc$P_pred_poly)
# dsc$RES_poly_ghq <- -(dsc$SR_poly_ghq)
# 
# # phq SR score
# ## random slopes and intercepts
# 
# EP      <- lm(scale(phq) ~ poly(scale(E),1,raw = TRUE),data=dsc)  
# EP_poly <- lm(scale(phq) ~ poly(scale(E),2,raw = TRUE),data=dsc)  
# 
# 
# ### compare model fits
# anova(EP,EP_poly,test="Chisq")
# 
# 
# ### plot differ EP lines
# 
# plot <- ggplot(dsc, aes(x = scale(E), y = scale(phq))) +
#   geom_point() +
#   labs(x="E", y="P") +
#   geom_smooth(method = "lm") +
#   ggtitle("Linear EP line phq")
# 
# plot <- ggplot(dsc, aes(x = scale(E), y = scale(phq))) +
#   geom_point() +
#   labs(x="E", y="P") +
#   geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
#     ggtitle("quadratic E-P line phq")
# 
# 
# ## calc linear SR score
# intercept = summary(EP)$coefficients[1]
# E_slope = summary(EP)$coefficients[2]
# 
# ### predicted E wwould be predE = slope*actualE + intercept
# ### calculate predicted E based on this formula
# dsc$P_pred = (intercept + scale(dsc$E)*E_slope)
# 
# dsc$SR_phq= scale(scale(dsc$phq) - dsc$P_pred)
# dsc$RES_phq = -(dsc$SR_phq)
# 
# 
# ## poly SR score
# intercept_poly = summary(EP_poly)$coefficients[1]
# E_slope_poly = summary(EP_poly)$coefficients[2]
# E_slope2_poly = summary(EP_poly)$coefficients[3]
# 
# ### predicted E wwould be predE = slope*actualE + intercept
# ## #calculate predicted E based on this formula
# 
# dsc$P_pred_poly = (intercept_poly + scale(dsc$E)*E_slope_poly + (scale(dsc$E)^2)*E_slope2_poly)
# 
# 
# dsc$SR_poly_phq = scale(scale(dsc$phq) -dsc$P_pred_poly)
# dsc$RES_poly_phq <- -(dsc$SR_poly_phq)
# 
# 
# # correlations 
# psych::pairs.panels(dsc[c("RES_phq", "RES_poly_phq","RES_ghq", "RES_poly_ghq", "ghq", "phq")], 
#              method = "pearson", # correlation method
#              hist.col = "#00AFBB",
#              density = TRUE,  # show density plots
#              ellipses = TRUE, # show correlation ellipses
#              main = "over all timepoints"
#              )

```

