---
title: "sr_explore_heroes"
author: "Papoula Petri-Romao"
date: "2022-11-15"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

require(pacman)
p_load(tidyverse,
       psych,
       lme4)

ds <- readRDS("data/heroes_wp2_anonymised.rds")


```

currently "prefer not to issues" are not recoded as -992. therefore we are recoding them here. This should run when the final ipd dataset is corrected. 

```{r basic-recoding}

ds <- ds %>%	        
        
  mutate(sd03 = recode(sd03,"2"= NA_character_),	        
        
         # sd05 = recode(sd05, "6" = NA_character_),	        
        
         # sd06 = recode(sd06, "6" = NA_character_),	        
        
         # tr13 = recode(tr13, "5" = NA_character_),	        
        
         # mp19 = recode(mp19, "4" = NA_character_),	        
        
         mp25b = recode(mp25b, "3" = NA_character_),	# RMT: "2" = "I do not know"        
        
         # ep31 = recode(ep31, "2" = NA_character_),	        
        
         ep32 = recode(ep32,	        
        
                       "2"= NA_character_,	        
        
                       "3"= NA_character_),	        
        
         ep32a = recode(ep32a, "4" = NA_character_),	        
        
         # sp64 = recode(sp64, "2" = NA_character_),	        
        
         # sp65 = recode(sp65, "2" = NA_character_),	        
        
         # sp66 = recode(sp66, "2" = NA_character_),	        
        
         sp66b1 = recode(sp66b1, "6" = NA_character_),	# RMT: Do you actually use these stressors?        
        
         sp66b2 = recode(sp66b2, "6" = NA_character_),	        
        
         sp66b3 = recode(sp66b3, "6" = NA_character_),	        
        
         sp66b4 = recode(sp66b4, "6" = NA_character_),	        
        
         sp66b5 = recode(sp66b5, "6" = NA_character_),	        
        
         sp66b6 = recode(sp66b6, "6" = NA_character_),	        
        
         sp66b7 = recode(sp66b7, "6" = NA_character_),	        
        
        )

```

# defining and mutating stressors

TR16: days worked, should more than 5 days be a stressor? *RMT Probably 6-7 days a week should be a stressor: many HCWs did not rest for weeks*.
TR17: hours worked on those days == should that be a stressors *RMT Hard to interpret: 16- or 24-hour shift are common among HCWs in Spain*
MP25c: stigma, if any agreement then stressor *RMT We did a paper on this. Is linked to MH. I would include it*

MP25d: frequency of conflicts, does it make sense to count? *RMT This I don't trust very much. Perhaps MP25e is better (violence due to job)*

EP32a: should we include feeling remorse? is that somehow the stressor severity? *We used just EP32 in a previous work and it did fine. Having to discriminate is usually stressing enough and is often followed by remorse. I am also afraid that there may be much more missing data in the EP32a.*

EP27a-d; double check variable code

psychological support: I suggest two alternatives of recoding. also, I am not sure that we can say that they are stressors. because they could also reduce stress. so maybe we should take them out all together

trust: again, it might be worth looking at them separately, as I am not sure we can say that they are stressors. 

RA56: what are the answer options?


## notes 29/11 PPR

ehc_4: in wave one, everyone should be one, not sure what happened. >> answer options appear to change for MP18aa in wave 2 and 3, please check. 

ehc_5: the answer options for MP25b don't appear to correspond with codebook. more options than 1 and 0

ehc7: double check answer options and recoding PPR

ehc8: something is amiss, as based on raw data we would expect over 500 1s. 

ehc9: answer options in codebook are less than actual answer options >> doublecheck ep32

ec_3: MP18ab>> answer options seem to change in wave 2 and 3 
## explanation of recoding
the recoding of stressors are based on the following variables

**expected answer format especially interesting considering recoding in previous chunk**

### EHC stressors

    - TR15: Assigned to new team in past 3 months. Expected answer format: 0 1. Actual answers: 2 3. Basis for ehc_1
    - TR16: Days worked past week. Expected answer format: free. Actual: free. Basis for ehc_2 & ehc_3. 
    - TR17: Hour worked. Expected answer format: free. Actual: free. Basis for ehc_3. 
    - MP18aa: Working in a COVID unit. Expected answer format: 0 1. Actual answer format: 1. Basis for: ehc_4 RMT: NOT IN WAVE 1
    - mp25b: death of a patient. Expected answer format:0 1. Actual answers. 2 3 4. Basis for: ehc_5
    - MP25c: stigma. Expected answer format: Likert 1 2 3 4. Actual answers 2 3 4 5. Basis for: ehc_6
    - MP25d: conflict at work. Expected answer format: Likert 0 1 2 3 4 5. Actual: 2 3 4 5. Basis for: ehc_7
    - MP25e: Violence at work. Expected answer format: Likert 1 2 3 4. Actual: 2 3 4 5. Basis for: ehc_8
    - EP32: Need to prioritise covid patients. Expected answer format: 0 1 2(N/A) Actual: 2 3 .Basis for: ehc_9


### EC stressors

    - MP18: close contact. Expected answer format: 0 1 2. Actual: 2 3 4. Basis for: ec_1
    - MP21: worried about getting covid. Expected answer format: Likert 0 1 2 3. Actual: 2 3 4 5. Basis for: ec_2
    - MP23: worried about infecting someone.Expected answer format: Likert 0 1 2 3. Actual: 2 3 4 5. Basis for: ec_3
    - MP18ab: infection. Expected answer format: 0 1 2. Actual 1. Basis for ec_4 RMT: NOT IN WAVE 1
    - MP22: days isolation. Expected answer format: free. Actual: free. Basis for: ec_5
    - MP25: death close one. Expected answer format: 0 1. Actual: 2 3. Basis for: ec_5
    - MP25aa: death at work. Expected answer format: 0 1. Actual: 1. Basis for: ec_6 RMT: NOT IN WAVE 1
    

### To potentially add: 

MP24: loved one had covid

### Considered but discarded

    - EP27a: received training >> strata
    - SD08: live with child. >> regular life, not necessarily a stressor. 
    - SD09: living with elderly >> not a stressor
    - SD10: living with people with disability >> not a stressor
    - MP25g: trust in government >> too subjective, not a stressor
    - MP25e: trust information >> too subjective, not a stressor
    - MP25f: perceived management by leaders
    - MP25fb: perceived management by colleagues
    - R52a-d etc: different types of support received. >> Receiving support could alleviate a stressor or could mark the presence of stress, but we cannot distinguish that. 
    

```{r stressors, echo=TRUE}

stressors <- read.csv("stressors_heroes.csv")


# healthcare worker specific stressors

ds <- ds %>%
  mutate(
    ehc_1 = case_when(tr15 == 1 ~ 1,
                      tr15 == -991~-991,
                      tr15 == -993~-993,
                      tr15 == NA_character_~NA_real_,
                   tr15 == 0 ~ 0), # Assigned to new team in past 3 months
    ehc_2 = case_when(tr16 >= 6 ~ 1,
                      tr16 == -991~-991,
                      tr16 == -993~-993,
                      tr16 == NA_character_~NA_real_,
                      TRUE ~ 1), # days worked past week
    ehc_3 = case_when((tr16 > 5 & tr17 >= 12)~ 1,
                      tr16 == -991~-991,
                      tr16 == -993~-993,
                      tr16 == NA_character_~NA_real_,
                      TRUE ~ 1), #  hours worked on those days
    ehc_4 = case_when(mp18aa == 1~1,
                      mp18aa == 0 ~0,
                      mp18aa == -991~-991,
                      mp18aa == NA_character_~NA_real_,
                      mp18aa == -993~-993), # covid-19 unit RMT: strata?
    ehc_5 = case_when(mp25b == 1 ~1,
                      mp25b == 0 ~ 0,
                      mp25b == -991~-991,
                      mp25b == NA_character_~NA_real_,
                      mp25b == -993~-993), # death of patient
    ehc_6 = case_when(mp25c == 1 ~ 0,
                      mp25c == 2 ~ 0,
                      mp25c == 3 ~ 1,
                      mp25c == 4 ~ 1,
                      mp25c == 5 ~ 1, # RMT: I think there is no value = 5
                      mp25c == NA_character_~NA_real_,
                      mp25c == -991~-991,
                      mp25c == -993~-993), # stigma
    ehc_7 = case_when(mp25d == 0 ~ 0, # RMT: this is Likert 0 to 3 so I assume this line is not needed
                      mp25d == -991~-991,
                      mp25d == -993~-993,
                      mp25d == NA_character_~NA_real_,
                      TRUE ~ 1), # conflicts at work RMT: strata?
    ehc_8 = case_when(mp25e == 1 ~ 0,
                      mp25e == 2 ~ 0,
                      mp25e == 3 ~ 1,
                      mp25e == 4 ~ 1,
                      mp25e == 5 ~ 1,
                      mp25e == NA_character_~NA_real_,
                      mp25e == -991~-991,
                      mp25e == -993~-993), # violence due to health worker
    ehc_9 = case_when(ep32 == 1 ~1,
                      ep32 == 0 ~ 0,
                      ep32 == -991~-991,
                      ep32 == -993~-993,
                      ep32== NA_character_~NA_real_,
                      TRUE ~ 0) # need to prioritise patients
    )

# general stressors

## so here I wasn't sure whether the issue you described with psychol support means that the same variable was assessed under different names, if so I would suggest an alternative below

## RMT: remove support in general; keep social support at work as strata

# ds <- ds %>%
#   mutate(
#     eg_1 = case_when(sd08 == 1 ~1,
#                      TRUE ~ 0), # living with children
#     eg_2 = case_when(sd09 == 1 ~1,
#                      TRUE ~ 0), # living with elderly
#     eg_3 = case_when(sd10 == 1 ~ 1,
#                      TRUE ~ 0)) # living with someone who has disability
  

# covid stressors
ds <- ds %>%
  mutate(
    ec_1 = case_when(mp18 == 1 ~1,
                     mp18 == -991~-991,
                     mp18 == -993~-993,
                     mp18 == NA_character_~NA_real_,
                     TRUE ~ 0), # close contact
    ec_2 = case_when(mp21 == 1 ~1,
                     mp21 == 2 ~1,
                     mp21 == 3 ~1,
                     mp21 == -991~-991,
                     mp21 == -993~-993,
                     mp21 == NA_character_~NA_real_,
                     TRUE ~ 0), # worried about getting infected
    ec_2 = case_when(mp23 == 1 ~1,
                     mp23 == 2 ~1,
                     mp23 == 3 ~1,
                     mp23 == -991~-991,
                     mp23 == -993~-993,
                     mp23 == NA_character_~NA_real_,
                     TRUE ~ 0), # worried about infecting someone
    ec_3 = case_when(mp18ab == 1 ~1,
                     mp18ab == -991~-991,
                     mp18ab == -993~-993,
                     mp18ab== NA_character_~NA_real_,
                     TRUE ~ 0), # infected with COVID
    ec_4 = case_when(mp22 >=1 ~1,
                     mp22 == -991~-991,
                     mp22 == -993~-993,
                     mp22 == NA_character_~NA_real_,
                     TRUE ~ 0), # days in isolation
    ec_5 = case_when(mp25 == 1 ~ 1,
                     mp25 == -991~-991,
                     mp25 == -993~-993,
                     mp25 == NA_character_~NA_real_,
                     TRUE ~ 0), # death duie to covid
    ec_6 = case_when(mp25aa == 1 ~ 1,
                     mp25aa == -991~-991,
                     mp25aa == -993~-993,
                     TRUE ~ 0) # death at work
      )

# trust stressors RMT: too subjective for strata and probably too non-individual for stressors but think about it
# 
# ds <- ds %>%
#   mutate(
#     et_1 = case_when(mp25g == 0 ~1,
#                      mp25g == -991~-991,
#                      mp25g == -993~-993,
#                      TRUE ~ 0), # trust government
#     et_2 = case_when(mp25ea == 0 ~1,
#                      mp25ea == -991~-991,
#                      mp25ea == -993~-993,
#                      TRUE ~ 0), # trust information
#     et_3 = case_when(mp25f == 0 ~1,
#                      mp25f== -991~-991,
#                      mp25f == -993~-993,
#                      TRUE ~ 0), # trust work leadership
#     et_4 = case_when(mp25fb == 0~1,
#                      mp25fb == -991~-991,
#                      mp25fb == -993~-993,
#                      TRUE ~ 0) # trust colleagues
#   )

# relation
# ds <- ds %>%
#   mutate(
#     e_rel = case_when(ra56 == 1 ~ 0,
#                       ra56 == 2 ~ 0,
#                       ra56 == 3 ~ 1,
#                       ra56 == 4 ~ 1,
#                       ra56 == 5 ~ 1,) # how did pandemic affect you
#   )



```

## separating datset

```{r waves}
# dataset wave 1
ds1 <- ds %>%
  dplyr::filter(wave=="1") %>%
  dplyr::filter(assessment_week !=-993)%>%
  group_by(hashed_id)

# dataset of wave two
ds2 <- ds %>%
  dplyr::filter(wave=="2") %>%
  dplyr::filter(assessment_week !=-993)%>%
  group_by(hashed_id)
  
# dataset of wave three
ds3 <- ds %>%
  dplyr::filter(wave=="3") %>%
  dplyr::filter(assessment_week !=-993)%>%
  group_by(hashed_id)

# here I try to create a complete dataset 
dsc <- ds %>%
  dplyr::filter(hashed_id %in% ds1$hashed_id &
                hashed_id %in% ds2$hashed_id &
                hashed_id %in% ds3$hashed_id)%>%
  group_by(hashed_id)


ds %>%
  filter(wave == "1") %>% 
  select(assessment_week) %>%
  table()
  
```

# replace NAs

```{r function,include=FALSE}


ds <- ds %>% mutate(across(where(is.factor), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_))) %>% 
  mutate(across(where(is.numeric), .fns = ~recode(.x, `-993`= NA_real_, `-991`= NA_real_,))) %>% 
  mutate(across(where(is.character) & !hashed_id, .fns = ~recode(.x,  "-991" = NA_character_,"-993" = NA_character_)))

ds1 <- ds1 %>% mutate(across(where(is.factor), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_))) %>% 
  mutate(across(where(is.numeric), .fns = ~recode(.x, `-993`= NA_real_, `-991`= NA_real_,))) %>% 
  mutate(across(where(is.character), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_)))

ds2 <- ds2 %>% mutate(across(where(is.factor), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_))) %>% 
  mutate(across(where(is.numeric), .fns = ~recode(.x, `-993`= NA_real_, `-991`= NA_real_,))) %>% 
  mutate(across(where(is.character), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_)))

ds3 <- ds3 %>% mutate(across(where(is.factor), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_))) %>% 
  mutate(across(where(is.numeric), .fns = ~recode(.x, `-993`= NA_real_, `-991`= NA_real_,))) %>% 
  mutate(across(where(is.character), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_)))

dsc <- dsc %>% mutate(across(where(is.factor), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_))) %>% 
  mutate(across(where(is.numeric), .fns = ~recode(.x, `-993`= NA_real_, `-991`= NA_real_,))) %>% 
  mutate(across(where(is.character), .fns = ~recode(.x, "-993" = NA_character_, "-991" = NA_character_)))

```

# decriptives

RMT general comment:
Since we are not sure about anything,
I suggest we focus on the first wave only.
That includes these descriptive tables
(Alternatively, I would show these values stratified by wave)

```{r describe}

# some summaries

e_items <- grep("ehc_|e_rel|et_|eg_|ec_", names(ds), value = TRUE)
e_raw <- c("mp18", "mp21", "mp23", "mp18ab","mp22", "mp25", "mp25aa", "tr15", "tr16", "mp18aa", "mp25b", "mp25c", "mp25d", "mp25e", "ep32")


ehc <- grep("ehc_", names(ds), value = TRUE)

ec <- grep("ec_", names(ds), value = TRUE)

e_rel <- grep("e_rel", names(ds), value = TRUE)
et <- grep("et_", names(ds), value = TRUE)
eg <- grep("eg_", names(ds), value = TRUE)


knitr::kable(psych::describe(ds[e_items]))
knitr::kable(psych::describe(ds[e_raw]))

## hours worked what would be consider impossible values
which(ds[e_raw] > 99, arr.ind = TRUE) 
ds[2025,"tr16"]  <- NA_real_ # impossible value 7777
# ds[2111,"tr16"]  <- NA_real_ # 211 hours worked

## days in isolation, what are impossible values?
which(ds[e_raw] > 50, arr.ind = TRUE)

ggplot2::ggplot(data=ds,aes(x = factor(wave), 
                                y = rowSums(ds[e_items], na.rm = TRUE)
                                )
                            ) + 
 geom_violin(position=position_dodge(1), 
             trim = FALSE
             ) +
  geom_boxplot(width = 0.05,
  position = position_dodge(0.9) 
  # color = "black"
  )+
  geom_smooth(method = "lm", se=TRUE
              ) +
  ggtitle("Healhtcare worker stressors", subtitle = "")+
  xlab("Timepoints")+
  ylab("E") # RMT: this plot makes sense: more stressors during the first wave (right?)


ggplot2::ggplot(data=ds,aes(x = factor(wave), 
                                y = psych::scoreItems(e_raw, ds[e_raw])$scores
                                )
                            ) + 
 geom_violin(position=position_dodge(1), 
             trim = FALSE
             ) +
  geom_boxplot(width = 0.05,
  position = position_dodge(0.9) 
  # color = "black"
  )+
  geom_smooth(method = "lm", se=TRUE
              ) +
  ggtitle("Healhtcare worker stressors RAW", subtitle = "")+
  xlab("Timepoints")+
  ylab("E") 

```




# first plots

# I found these counts a bit confusing, since sample sizes
# vary substantially across waves

```{r first look}

## ehc
ds[c(e_items, "hashed_id", "wave")] %>%
  gather("Type", "Value",-hashed_id, -wave) %>%
  ggplot(aes(x=as.factor(Value), group=wave))+
  geom_bar(aes(fill=wave),position="dodge")+
  facet_wrap(~Type,scales = "free_x") +
  ggtitle("Count of hc stressors", subtitle = "")+
  xlab("Answer")+
  ylab("Count") 

## raw
ds[c(e_raw, "hashed_id", "wave")] %>%
  gather("Type", "Value",-hashed_id, -wave) %>%
  ggplot(aes(x=as.factor(Value), group=wave))+
  geom_bar(aes(fill=wave),position="dodge")+
  facet_wrap(~Type,scales = "free_x")+
  ggtitle("Count of RAW hc stressors", subtitle = "")+
  xlab("Answer")+
  ylab("Count") 


## ec
ds[c(ec, "hashed_id", "wave")] %>%
  gather("Type", "Value",-hashed_id, -wave) %>%
  ggplot(aes(x=as.factor(Value), group=wave))+
  geom_bar(aes(fill=wave),position="dodge")+
  facet_wrap(~Type,scales = "free_x")+
  ggtitle("Count of covid stressors", subtitle = "")+
  xlab("Answer")+
  ylab("Count") 

```

# descriptives by wave

```{r deswave1}
# wave 1 --------------------------------------
knitr::kable(psych::describe(ds1[e_items]))
knitr::kable(psych::describe(ds1[e_raw]))


## ehc
ds1[c(e_items, "hashed_id")] %>%
  gather("Type", "Value",-hashed_id) %>%
  ggplot(aes(x=as.factor(Value)))+
  geom_bar(position="dodge")+
  facet_wrap(~Type,scales = "free_x") +
  ggtitle("Count of hc stressors", subtitle = "")+
  xlab("Answer")+
  ylab("Count") 

## raw
ds1[c(e_raw, "hashed_id")] %>%
  gather("Type", "Value",-hashed_id) %>%
  ggplot(aes(x=as.factor(Value)))+
  geom_bar(position="dodge")+
  facet_wrap(~Type,scales = "free_x") +
  ggtitle("Count of RAW hc stressors", subtitle = "")+
  xlab("Answer")+
  ylab("Count") 


## ec
ds1[c(ec, "hashed_id")] %>%
  gather("Type", "Value",-hashed_id) %>%
  ggplot(aes(x=as.factor(Value)))+
  geom_bar(position="dodge")+
  facet_wrap(~Type,scales = "free_x") +
  ggtitle("Count of covid stressors", subtitle = "")+
  xlab("Answer")+
  ylab("Count") 

# wave 2 --------------------------------------
knitr::kable(psych::describe(ds2[e_items]))
knitr::kable(psych::describe(ds2[e_raw]))


## ehc
ds2[c(e_items, "hashed_id")] %>%
  gather("Type", "Value",-hashed_id) %>%
  ggplot(aes(x=as.factor(Value)))+
  geom_bar(position="dodge")+
  facet_wrap(~Type,scales = "free_x") +
  ggtitle("Count of hc stressors", subtitle = "")+
  xlab("Answer")+
  ylab("Count") 

## raw
ds2[c(e_raw, "hashed_id")] %>%
  gather("Type", "Value",-hashed_id) %>%
  ggplot(aes(x=as.factor(Value)))+
  geom_bar(position="dodge")+
  facet_wrap(~Type,scales = "free_x") +
  ggtitle("Count of RAW hc stressors", subtitle = "")+
  xlab("Answer")+
  ylab("Count") 


## ec
ds2[c(ec, "hashed_id")] %>%
  gather("Type", "Value",-hashed_id) %>%
  ggplot(aes(x=as.factor(Value)))+
  geom_bar(position="dodge")+
  facet_wrap(~Type,scales = "free_x") +
  ggtitle("Count of covid stressors", subtitle = "")+
  xlab("Answer")+
  ylab("Count") 


# wave 3 --------------------------------------
knitr::kable(psych::describe(ds3[e_items]))
knitr::kable(psych::describe(ds3[e_raw]))


## ehc
ds3[c(e_items, "hashed_id")] %>%
  gather("Type", "Value",-hashed_id) %>%
  ggplot(aes(x=as.factor(Value)))+
  geom_bar(position="dodge")+
  facet_wrap(~Type,scales = "free_x") +
  ggtitle("Count of hc stressors", subtitle = "")+
  xlab("Answer")+
  ylab("Count") 

## raw
ds3[c(e_raw, "hashed_id")] %>%
  gather("Type", "Value",-hashed_id) %>%
  ggplot(aes(x=as.factor(Value)))+
  geom_bar(position="dodge")+
  facet_wrap(~Type,scales = "free_x") +
  ggtitle("Count of RAW hc stressors", subtitle = "")+
  xlab("Answer")+
  ylab("Count") 


## ec
ds3[c(ec, "hashed_id")] %>%
  gather("Type", "Value",-hashed_id) %>%
  ggplot(aes(x=as.factor(Value)))+
  geom_bar(position="dodge")+
  facet_wrap(~Type,scales = "free_x") +
  ggtitle("Count of covid stressors", subtitle = "")+
  xlab("Answer")+
  ylab("Count") 

```
# wave 1

We calculate SR scores based on mental health exposure. 
In the Dynacore studies we base this of GHQ. As we want to know mental health problems and not necessarily symptoms.
However, in RESPOND WP4 we use PHQ & GAd7 as the basis of the SR score, as the sample is highly distressed. This results in a good SR measure. 
Therefore we here compare an SR score based on GHQ and one on PHQ. 

*the results indicate that more investment should be put in the definition of stressors, as there is virtually no different pattern with phq*

Questions:

    - should we impute data in ghq/phq
    - should we impute data in E scores

```{r wave-1}

ds1$ehc <-rowSums(ds1[ehc], na.rm = TRUE)
ds1$ec <-rowSums(ds1[ec], na.rm = TRUE)
ds1$E <-rowSums(ds1[c(ehc, ec)], na.rm = TRUE)
ds1$ehc_raw <-psych::scoreItems(e_raw, ds1[e_raw])$scores



ghq <- grep("^ad", names(ds1), value = TRUE)
psych::scoreItems(ghq,items=ds1[ghq], impute = "median", totals = TRUE)
ds1$ghq <-psych::scoreItems(ghq,items=ds1[ghq], impute = "median", totals = TRUE)$scores

phq <- grep("^phq..$", names(ds1), value = TRUE)
psych::scoreItems(phq,items=ds1[phq], impute = "median", totals = TRUE)
ds1$phq <-psych::scoreItems(phq,items=ds1[phq], impute = "median", totals = TRUE)$scores



psych::pairs.panels(ds1[c("ehc", "ec", "E", "ehc_raw", "ghq", "phq" )], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             main = "over all timepoints"
             )


```
## sr scores, ghq, pqhq
Unfortunately, the SR score and GHQ are basically the same. 



```{r sr_score_plot1}

# GHQ SR score
## random slopes and intercepts

EP      <- lm(scale(ghq) ~ poly(scale(E),1,raw = TRUE),data=ds1)  
EP_poly <- lm(scale(ghq) ~ poly(scale(E),2,raw = TRUE),data=ds1)  


### compare model fits
anova(EP,EP_poly,test="Chisq")


### plot differ EP lines

plot <- ggplot(ds1, aes(x = scale(E), y = scale(ghq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(method = "lm") +
  ggtitle("Linear EP line GHQ")

plot <- ggplot(ds1, aes(x = scale(E), y = scale(ghq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
    ggtitle("quadratic E-P line GHQ")


## calc linear SR score
intercept = summary(EP)$coefficients[1]
E_slope = summary(EP)$coefficients[2]

### predicted E wwould be predE = slope*actualE + intercept
### calculate predicted E based on this formula
ds1$P_pred = (intercept + scale(ds1$E)*E_slope)

ds1$SR_ghq= scale(scale(ds1$ghq) - ds1$P_pred)
ds1$RES_ghq = -(ds1$SR_ghq)


## poly SR score
intercept_poly = summary(EP_poly)$coefficients[1]
E_slope_poly = summary(EP_poly)$coefficients[2]
E_slope2_poly = summary(EP_poly)$coefficients[3]

### predicted E wwould be predE = slope*actualE + intercept
## #calculate predicted E based on this formula

ds1$P_pred_poly = (intercept_poly + scale(ds1$E)*E_slope_poly + (scale(ds1$E)^2)*E_slope2_poly)


ds1$SR_poly_ghq = scale(scale(ds1$ghq) -ds1$P_pred_poly)
ds1$RES_poly_ghq <- -(ds1$SR_poly_ghq)

# phq SR score
## random slopes and intercepts

EP      <- lm(scale(phq) ~ poly(scale(E),1,raw = TRUE),data=ds1)  
EP_poly <- lm(scale(phq) ~ poly(scale(E),2,raw = TRUE),data=ds1)  


### compare model fits
anova(EP,EP_poly,test="Chisq")


### plot differ EP lines

plot <- ggplot(ds1, aes(x = scale(E), y = scale(phq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(method = "lm") +
  ggtitle("Linear EP line phq")

plot <- ggplot(ds1, aes(x = scale(E), y = scale(phq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
    ggtitle("quadratic E-P line phq")


## calc linear SR score
intercept = summary(EP)$coefficients[1]
E_slope = summary(EP)$coefficients[2]

### predicted E wwould be predE = slope*actualE + intercept
### calculate predicted E based on this formula
ds1$P_pred = (intercept + scale(ds1$E)*E_slope)

ds1$SR_phq= scale(scale(ds1$phq) - ds1$P_pred)
ds1$RES_phq = -(ds1$SR_phq)


## poly SR score
intercept_poly = summary(EP_poly)$coefficients[1]
E_slope_poly = summary(EP_poly)$coefficients[2]
E_slope2_poly = summary(EP_poly)$coefficients[3]

### predicted E wwould be predE = slope*actualE + intercept
## #calculate predicted E based on this formula

ds1$P_pred_poly = (intercept_poly + scale(ds1$E)*E_slope_poly + (scale(ds1$E)^2)*E_slope2_poly)


ds1$SR_poly_phq = scale(scale(ds1$phq) -ds1$P_pred_poly)
ds1$RES_poly_phq <- -(ds1$SR_poly_phq)


# correlations 
psych::pairs.panels(ds1[c("RES_phq", "RES_poly_phq","RES_ghq", "RES_poly_ghq", "ghq", "phq")], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             main = "over all timepoints"
             )

```

# wave 2

In wave two we have the GAD7, so we can use the PHQADS as the basis of the SR score. 

```{r wave-2}

ds2$ehc <-rowSums(ds2[ehc], na.rm = TRUE)
ds2$ec <-rowSums(ds2[ec], na.rm = TRUE)
ds2$E <-rowSums(ds2[c(ehc, ec)], na.rm = TRUE)
ds2$ehc_raw <-psych::scoreItems(e_raw, ds2[e_raw])$scores



ghq <- grep("^ad", names(ds2), value = TRUE)
psych::scoreItems(ghq,items=ds2[ghq], impute = "median", totals = TRUE)
ds2$ghq <-psych::scoreItems(ghq,items=ds2[ghq], impute = "median", totals = TRUE)$scores

phq <- grep("^phq..$", names(ds2), value = TRUE)
psych::scoreItems(phq,items=ds2[phq], impute = "median", totals = TRUE)
ds2$phq <-psych::scoreItems(phq,items=ds2[phq], impute = "median", totals = TRUE)$scores



psych::pairs.panels(ds2[c("ehc", "ec", "E", "ehc_raw", "ghq", "phq" )], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             main = "over all timepoints"
             )


```


# wave 3

```{r wave-3}
ds3$ehc <-rowSums(ds3[ehc], na.rm = TRUE)
ds3$ec <-rowSums(ds3[ec], na.rm = TRUE)
ds3$E <-rowSums(ds3[c(ehc, ec)], na.rm = TRUE)
ds3$ehc_raw <-psych::scoreItems(e_raw, ds3[e_raw])$scores



ghq <- grep("^ad", names(ds3), value = TRUE)
psych::scoreItems(ghq,items=ds3[ghq], impute = "median", totals = TRUE)
ds3$ghq <-psych::scoreItems(ghq,items=ds3[ghq], impute = "median", totals = TRUE)$scores

phqads <- grep("^phq..$|^gad", names(ds3), value = TRUE)
psych::scoreItems(phqads,items=ds3[phqads], impute = "median", totals = TRUE)
ds3$phqads <-psych::scoreItems(phqads,items=ds3[phqads], impute = "median", totals = TRUE)$scores

phq <- grep("^phq..$", names(ds3), value = TRUE)
psych::scoreItems(phq,items=ds3[phq], impute = "median", totals = TRUE)
ds3$phq <-psych::scoreItems(phq,items=ds3[phq], impute = "median", totals = TRUE)$scores



psych::pairs.panels(ds3[c("ehc", "ec", "E", "ehc_raw", "ghq", "phqads", "phq")], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             main = "over all timepoints"
             )

```

## sr scores wave 3 ghq, phq, phqads

```{r sr-wave3}

# GHQ SR score -------------------------------------------------------------
## random slopes and intercepts

EP      <- lm(scale(ghq) ~ poly(scale(E),1,raw = TRUE),data=ds3)  
EP_poly <- lm(scale(ghq) ~ poly(scale(E),2,raw = TRUE),data=ds3)  


### compare model fits
anova(EP,EP_poly,test="Chisq")


### plot differ EP lines

plot <- ggplot(ds3, aes(x = scale(E), y = scale(ghq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(method = "lm") +
  ggtitle("Linear EP line GHQ")

plot <- ggplot(ds3, aes(x = scale(E), y = scale(ghq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
    ggtitle("quadratic E-P line GHQ")


## calc linear SR score
intercept = summary(EP)$coefficients[1]
E_slope = summary(EP)$coefficients[2]

### predicted E wwould be predE = slope*actualE + intercept
### calculate predicted E based on this formula
ds3$P_pred = (intercept + scale(ds3$E)*E_slope)

ds3$SR_ghq= scale(scale(ds3$ghq) - ds3$P_pred)
ds3$RES_ghq = -(ds3$SR_ghq)


## poly SR score
intercept_poly = summary(EP_poly)$coefficients[1]
E_slope_poly = summary(EP_poly)$coefficients[2]
E_slope2_poly = summary(EP_poly)$coefficients[3]

### predicted E wwould be predE = slope*actualE + intercept
## #calculate predicted E based on this formula

ds3$P_pred_poly = (intercept_poly + scale(ds3$E)*E_slope_poly + (scale(ds3$E)^2)*E_slope2_poly)


ds3$SR_poly_ghq = scale(scale(ds3$ghq) -ds3$P_pred_poly)
ds3$RES_poly_ghq <- -(ds3$SR_poly_ghq)

# phq SR score------------------------------------------------------
## random slopes and intercepts

EP      <- lm(scale(phq) ~ poly(scale(E),1,raw = TRUE),data=ds3)  
EP_poly <- lm(scale(phq) ~ poly(scale(E),2,raw = TRUE),data=ds3)  


### compare model fits
anova(EP,EP_poly,test="Chisq")


### plot differ EP lines

plot <- ggplot(ds3, aes(x = scale(E), y = scale(phq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(method = "lm") +
  ggtitle("Linear EP line phq")

plot <- ggplot(ds3, aes(x = scale(E), y = scale(phq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
    ggtitle("quadratic E-P line phq")


## calc linear SR score
intercept = summary(EP)$coefficients[1]
E_slope = summary(EP)$coefficients[2]

### predicted E wwould be predE = slope*actualE + intercept
### calculate predicted E based on this formula
ds3$P_pred = (intercept + scale(ds3$E)*E_slope)

ds3$SR_phq= scale(scale(ds3$phq) - ds3$P_pred)
ds3$RES_phq = -(ds3$SR_phq)


## poly SR score
intercept_poly = summary(EP_poly)$coefficients[1]
E_slope_poly = summary(EP_poly)$coefficients[2]
E_slope2_poly = summary(EP_poly)$coefficients[3]

### predicted E wwould be predE = slope*actualE + intercept
## #calculate predicted E based on this formula

ds3$P_pred_poly = (intercept_poly + scale(ds3$E)*E_slope_poly + (scale(ds3$E)^2)*E_slope2_poly)


ds3$SR_poly_phq = scale(scale(ds3$phq) -ds3$P_pred_poly)
ds3$RES_poly_phq <- -(ds3$SR_poly_phq)

# phqads SR score ---------------------------------------------------------
## random slopes and intercepts

EP      <- lm(scale(phqads) ~ poly(scale(E),1,raw = TRUE),data=ds3)  
EP_poly <- lm(scale(phqads) ~ poly(scale(E),2,raw = TRUE),data=ds3)  


### compare model fits
anova(EP,EP_poly,test="Chisq")


### plot differ EP lines

plot <- ggplot(ds3, aes(x = scale(E), y = scale(phqads))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(method = "lm") +
  ggtitle("Linear EP line phqads")

plot <- ggplot(ds3, aes(x = scale(E), y = scale(phqads))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
    ggtitle("quadratic E-P line phqads")


## calc linear SR score
intercept = summary(EP)$coefficients[1]
E_slope = summary(EP)$coefficients[2]

### predicted E wwould be predE = slope*actualE + intercept
### calculate predicted E based on this formula
ds3$P_pred = (intercept + scale(ds3$E)*E_slope)

ds3$SR_phqads= scale(scale(ds3$phqads) - ds3$P_pred)
ds3$RES_phqads = -(ds3$SR_phqads)


## poly SR score
intercept_poly = summary(EP_poly)$coefficients[1]
E_slope_poly = summary(EP_poly)$coefficients[2]
E_slope2_poly = summary(EP_poly)$coefficients[3]

### predicted E wwould be predE = slope*actualE + intercept
## #calculate predicted E based on this formula

ds3$P_pred_poly = (intercept_poly + scale(ds3$E)*E_slope_poly + (scale(ds3$E)^2)*E_slope2_poly)


ds3$SR_poly_phqads = scale(scale(ds3$phqads) -ds3$P_pred_poly)
ds3$RES_poly_phqads <- -(ds3$SR_poly_phqads)


# correlations -----------------------------------------------------

psych::pairs.panels(ds3[c("RES_phqads", "RES_poly_phqads","RES_phq", "RES_poly_phq","RES_ghq", "RES_poly_ghq", "ghq", "phq", "phqads")], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             main = "over all timepoints"
             )

```



# complete dataset N~230

```{r ds-complete}

dsc$ehc <-rowSums(dsc[ehc], na.rm = TRUE)
dsc$ec <-rowSums(dsc[ec], na.rm = TRUE)
dsc$E <-rowSums(dsc[c(ehc, ec)], na.rm = TRUE)
dsc$ehc_raw <-rowSums(dsc[e_raw], na.rm = FALSE)



ghq <- grep("^ad", names(dsc), value = TRUE)
psych::scoreItems(ghq,items=dsc[ghq], impute = "median", totals = TRUE)
dsc$ghq <-psych::scoreItems(ghq,items=dsc[ghq], impute = "median", totals = TRUE)$scores

phq <- grep("^phq..$", names(dsc), value = TRUE)
psych::scoreItems(phq,items=dsc[phq], impute = "median", totals = TRUE)
dsc$phq <-psych::scoreItems(phq,items=dsc[phq], impute = "median", totals = TRUE)$scores



psych::pairs.panels(dsc[c("ehc", "ec", "E", "ehc_raw", "ghq", "phq" )], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             main = "over all timepoints"
             )


```

```{r sr-complete}

# GHQ SR score
## random slopes and intercepts

EP      <- lm(scale(ghq) ~ poly(scale(E),1,raw = TRUE),data=dsc)  
EP_poly <- lm(scale(ghq) ~ poly(scale(E),2,raw = TRUE),data=dsc)  


### compare model fits
anova(EP,EP_poly,test="Chisq")


### plot differ EP lines

plot <- ggplot(dsc, aes(x = scale(E), y = scale(ghq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(method = "lm") +
  ggtitle("Linear EP line GHQ")

plot <- ggplot(dsc, aes(x = scale(E), y = scale(ghq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
    ggtitle("quadratic E-P line GHQ")


## calc linear SR score
intercept = summary(EP)$coefficients[1]
E_slope = summary(EP)$coefficients[2]

### predicted E wwould be predE = slope*actualE + intercept
### calculate predicted E based on this formula
dsc$P_pred = (intercept + scale(dsc$E)*E_slope)

dsc$SR_ghq= scale(scale(dsc$ghq) - dsc$P_pred)
dsc$RES_ghq = -(dsc$SR_ghq)


## poly SR score
intercept_poly = summary(EP_poly)$coefficients[1]
E_slope_poly = summary(EP_poly)$coefficients[2]
E_slope2_poly = summary(EP_poly)$coefficients[3]

### predicted E wwould be predE = slope*actualE + intercept
## #calculate predicted E based on this formula

dsc$P_pred_poly = (intercept_poly + scale(dsc$E)*E_slope_poly + (scale(dsc$E)^2)*E_slope2_poly)


dsc$SR_poly_ghq = scale(scale(dsc$ghq) -dsc$P_pred_poly)
dsc$RES_poly_ghq <- -(dsc$SR_poly_ghq)

# phq SR score
## random slopes and intercepts

EP      <- lm(scale(phq) ~ poly(scale(E),1,raw = TRUE),data=dsc)  
EP_poly <- lm(scale(phq) ~ poly(scale(E),2,raw = TRUE),data=dsc)  


### compare model fits
anova(EP,EP_poly,test="Chisq")


### plot differ EP lines

plot <- ggplot(dsc, aes(x = scale(E), y = scale(phq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(method = "lm") +
  ggtitle("Linear EP line phq")

plot <- ggplot(dsc, aes(x = scale(E), y = scale(phq))) +
  geom_point() +
  labs(x="E", y="P") +
  geom_smooth(formula = y ~ poly(x, 2, raw=TRUE)) +
    ggtitle("quadratic E-P line phq")


## calc linear SR score
intercept = summary(EP)$coefficients[1]
E_slope = summary(EP)$coefficients[2]

### predicted E wwould be predE = slope*actualE + intercept
### calculate predicted E based on this formula
dsc$P_pred = (intercept + scale(dsc$E)*E_slope)

dsc$SR_phq= scale(scale(dsc$phq) - dsc$P_pred)
dsc$RES_phq = -(dsc$SR_phq)


## poly SR score
intercept_poly = summary(EP_poly)$coefficients[1]
E_slope_poly = summary(EP_poly)$coefficients[2]
E_slope2_poly = summary(EP_poly)$coefficients[3]

### predicted E wwould be predE = slope*actualE + intercept
## #calculate predicted E based on this formula

dsc$P_pred_poly = (intercept_poly + scale(dsc$E)*E_slope_poly + (scale(dsc$E)^2)*E_slope2_poly)


dsc$SR_poly_phq = scale(scale(dsc$phq) -dsc$P_pred_poly)
dsc$RES_poly_phq <- -(dsc$SR_poly_phq)


# correlations 
psych::pairs.panels(dsc[c("RES_phq", "RES_poly_phq","RES_ghq", "RES_poly_ghq", "ghq", "phq")], 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             main = "over all timepoints"
             )

```

